#!/bin/bash
# Script: trigger
# Description: This is the trigger engine. It crawls for IRC flags and triggers
#              the corresponding mods or scripts.
#
# - Manages the handling of $flag
# - Initiates corresponding modules if a command is triggered
# - Inititates the background scripts

# create channel and message segments
chan=$(echo $header | cut -d " " -f 3)
msg=${body:1}

case $flag in
	JOIN)
		egrep "^($msg$|$msg $)" < var/channels &> /dev/null || echo $msg >> var/channels
		continue
		;;
	PART)
		# since part messages don't come with the colon, we have to trick around a bit
		msg=$(echo $line | cut -d ' ' -f3)
		egrep -v "^($msg$|$msg $)" < var/channels > var/channels.tmp && mv var/channels.tmp var/channels || echo "" > var/channels && rm var/channels.tmp
		;;
	INVITE)
		. mods/join $msg
		continue
		;;
	KICK)
		# todo
		continue
		;;
	PRIVMSG)
		# create command and params segments
		if echo $msg | egrep "^$nick" &> /dev/null ; then
			# we have a command addressed by nick
			# first, cut the prepending nick from the line
			nick_prefix=$(echo $msg | cut -d ' ' -f 1)
			msg=${msg:$(expr ${#nick_prefix} + 1)}
			# then create $command and $params segments
			command=$(echo $msg | cut -d ' ' -f 1)
			params=${msg:$(expr ${#command} + 1)}
		fi
		if [[ "${msg:0:1}" == "$prefixchar" ]]; then
			# we have a command addressed by $prefixchar
			# cut the $prefixchar and create segments $command and $params
			command=$(echo $msg | cut -d ' ' -f 1)
			command=${command:1}
			params=${msg:$(expr ${#command} + 2)}
		else
			# we could have a command in a query
			command=$(echo $msg | cut -d ' ' -f 1)
			params=${msg:$(expr ${#command} + 1)}
		fi

		# Let the background scripts parse the msg first
		. scripts/*
		
		# Finally, source corresponding command module or reply with error
		if [[ -f mods/$command ]]; then
			. mods/$command $params
		else
			answer "I don't know what you are talking about, dude."
		fi
		;;
esac
